---
title: "OpenSSL & self-signed certifikater"
header:
  teaser: /assets/images/postimages/OpenSSLPost/OpenSSLHeader.png
  image: /assets/images/postimages/OpenSSLPost/OpenSSLHeader.pngg
  teaser: /assets/images/postimages/OpenSSLPost/OpenSSLHeader.png
sidebar:
    image: /assets/images/postimages/OpenSSLPost/OpenSSLHeader.png
    image_alt: "logo"
---
<h3>Ressourcer:</h3>
<ul>
    <li><a href="https://docs.openssl.org/master/man7/ossl-guide-libcrypto-introduction/">OpenSSL.docs, libcrypto</a></li>
    <li><a href="https://medium.com/@careertechnologymiraroad/openssl-75444bc7f3e6">Medium.com, OpenSSL</a></li>
</ul>
<p>
Jeg har brugt OpenSSL til at debugge og teste forbindelser mellem mine microservices og mellem microservice X og RabbitMQ. For mig har det været et helt uvurderligt værktøj som jeg har brugt til at få svar på spørgsmål så som <i> HVORFOR FAEN VIRKER DET IKKE?? </i> og <i> JEG ER SIKKER PÅ JEG HAR LAGT CERTIFIKATER HOS BÅDE CLIENT OG SERVER, HVORFOR MELDER DEN STADIG OM CERTIFIKAT-ISSUES????? </i>. 
<br>
OpenSSL er et open-source library som første gang så stueetagens lys i 1998. Det er skrevet i C og er cross-platform-venligt. Jeg har valgt at bruge diverse værktøjer igennem Windows Linux Subsystem og OpenSSL er et af dem. Det er ganske enkelt fordi det kom præinstalleret på min Ubuntu WLS, og fordi jeg fik øjnene op for OpenSSL da jeg skulle lave en tls-gen file ved brug af <i> make </i> og i den forbindelse skulle læse fra en openssl tekstfil. Det lod til at være overraskende forvirrende at få installeret <i>Make</i>-værktøjet til at virke på Windows, og overraskende nemt at bruge make og openssl i Linux og kopier filerne over på min Windows --- så det blev jeg ved.
OpenSSL er en værktøjskasse med en helt masse muligheder når det kommer til SSL og TLS. Helt uundværligt har det for mig været at jeg med OpenSSL nemt kan generere self-signed certifikater, som jeg bruger i development miljøet for den backend jeg er igang med at udvikle, hvori jeg har mTLS verificering sat op til alt kommunikation mellem services. <i>Let's Encrypt</i> udsteder kun certifikater til public domains, og vores produkt er langt fra i produktion eller hosted på et public domain endnu. Men når man taler TLS taler man også certifikater, og de skal komme et sted fra. 
<br> 
Skridtene til at genere et "simpelt" certifikat er ganske enkle: 
<br>
(I CLI med OpenSSL installeret)
<br>
Generer private key:
<i>1: openssl genpkey -algorithm RSA -out private_key.pem -aes256</i>
<br> 
Generer et 'Certificate Signing Request':
<br>
<i>openssl req -new -key private_key.pem -out request.csr</i>
<br>
Når ovenstående kommando eksekveres, promptes man for at angive Country, state, organization og Common Name, som bliver embedded i certifikatet. F.eks., så er det Common Name på det self-signed certifikat der automatisk udstedes på en maskine når man kører en ASP NET CORE app som handler https "localhost".
<br>
Generer certifikatet:
<br>
<i>openssl x509 -req -days 365 -in request.csr -signkey private_key.pem -out certificate.pem</i>
<br>
Og hermed kan dette certifikat f.eks. bruges af RabbitMQ (det skal være i .pem format når det skal stores i rabbitmq). Man kan også frit eksportere det til .p12 og .pfx. I pfx er indeholdt key og cert, og det er dette format jeg bruger til at mounte ind i mine microservices containere --- det håndterer .NET frameworket pænt, og forstår selv at udlede hvad det skal bruge, af dette format. 
</p>
<p>
<b>Eksempelcase på en troubleshooting:</b>
<br>
[TO BE CONTINUED]

